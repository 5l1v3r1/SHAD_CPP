а) a = (((b + (c * d)) << 2) & 8) Коректно.
Если b + (c * d) нечётное то a = 4 * (b + (c * d))
Иначе a = 4 * (b + (c * d) + 1)

б) (a & 077) |= 3 Не коректно.Но если создать какой нибудь класс перегруженными & и |= что & возвращает ссылку 
на то может быть и коректно.

в) (a == b) || ((a == c) && (c < 5)) Коректно. True когда a==b или когда a==c и они меньше 5.

г) c = (x != 0) Коректно. c = True если x!=0.

д) (0 <= I) < 7 Коректно. Для чисел всегда True.

е) 1,(2 + 3) Коректно. Равно 5.

ж) a=-1++b--5 Не коректно. -- и ++ унарные сдесь испольжуются как бинарные.

з) a = ((- 1) + (+ b)) - (- 5) Коректно. a = b + 4 (Для чисел)

и) a = (b == (c++)) Коректно. Эквивалентено a = (b == c); c++; 

к) a = (b = (c = 0)) Коректно. a = 0; b = 0; c = 0; (Для чисел)

л) a[4][2] *=((* b) ? c : ((*d)*2)) Коректно. Если a,b,d указатели с число. То если в памяти по указателю b 
хранится 0 то a[4][2] умножается на то что лежит под указателем d и ещё на 2 иначе умножается на с.

м) (a - b), (c = d) Коректно. Результат ссылка на с (Для чисел).

н) *(p++) Коректно. Если p указатель на эллемент массива то он перейдёт на следующий 
и результатом будет текущий эллемент массива.

о) *(--p) Коректно. Если p указатель на эллемент массива то он перейдёт на предыдущий эллемент
и результатом будет предыдущий эллемент.

п) ++(++(a--)) Не коректно для чисел. Если перегрузить -- что бы он возвращал ссылку то может стать коректно.

р) (-(++(++a)))-- Не коректно для чисел. Елси перегрузить минус чтобы он возвращал ссылку можетс 
стать коректно.

с) ++(a--) Не коректно для чисел. Если перегрузить -- что бы он возвращал ссылку то может стать коректно.

т) ((int*)p)->m Не коректно. В int нет поля m.

у) (*p).m Коректно. Если p указатель то результат поле m, того эллемента на котороый указывает указатель.

ф) *(a[i]) Коректно. Елси a массив указателей то результат эллемент на который указывает i-ый эллемент массива.